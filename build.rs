use std::fs::{self, File};
use std::io::Write;
use std::path::{Path, PathBuf};

fn main() {
    let configs_root = Path::new("src/configs");
    let mut json_files: Vec<PathBuf> = Vec::new();
    collect_json(configs_root, &mut json_files);

    // Generate Rust source that will include & parse each JSON at runtime init (fast, single pass)
    let out_dir = std::env::var("OUT_DIR").expect("OUT_DIR not set");
    let dest_path = Path::new(&out_dir).join("generated_configs.rs");
    let mut f = File::create(&dest_path).expect("create generated_configs.rs");

    writeln!(f, "// AUTO-GENERATED by build.rs - DO NOT EDIT BY HAND").unwrap();
    writeln!(f, "pub fn generated_configs() -> std::collections::HashMap<String, crate::structs::StatementConfig> {{").unwrap();
    writeln!(f, "    let mut map: std::collections::HashMap<String, crate::structs::StatementConfig> = std::collections::HashMap::new();").unwrap();

    for path in json_files {
        // Since build.rs executes with CWD at crate root, we can use the path relative to crate root.
        // Convert to forward slashes for cross-platform compatibility with include_str!
        // The include_str! macro always expects forward slashes, even on Windows
        let rel = path.strip_prefix(".").unwrap_or(&path)
            .to_string_lossy()
            .replace('\\', "/");  // Ensure forward slashes on all platforms
        // Skip any file we explicitly treat as generated or non-config
        if rel.ends_with("generated.rs") { continue; }
        writeln!(f, "    // Source: {rel}").unwrap();
    writeln!(f, "    if let Ok(cfg) = crate::structs::StatementConfig::from_json_str(include_str!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/{rel}\"))) {{").unwrap();
        writeln!(f, "        map.insert(cfg.key.clone(), cfg);").unwrap();
        writeln!(f, "    }} else {{").unwrap();
        writeln!(f, "        eprintln!(\"WARN: Failed to parse config {rel}\");").unwrap();
        writeln!(f, "    }}").unwrap();
    }

    writeln!(f, "    map").unwrap();
    writeln!(f, "}}").unwrap();
}

fn collect_json(dir: &Path, out: &mut Vec<PathBuf>) {
    if let Ok(entries) = fs::read_dir(dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                collect_json(&path, out);
            } else if let Some(ext) = path.extension() { if ext == "json" { out.push(path); } }
        }
    }
}
